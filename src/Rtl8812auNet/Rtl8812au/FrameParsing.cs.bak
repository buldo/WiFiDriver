namespace Rtl8812auNet.Rtl8812au;

public static class FrameParsing
{
    static void recvframe_put(recv_frame precvframe, int sz)
    {
        /* rx_tai += sz; move rx_tail sz bytes  hereafter */

        /* used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller */
        /* after putting, rx_tail must be still larger than rx_end. */
        byte[] prev_rx_tail;

        /* RTW_INFO("recvframe_put: len=%d\n", sz); */

        if (precvframe == null)
        {
            return;
        }

        prev_rx_tail = precvframe.hdr.rx_tail;

        precvframe.hdr.rx_tail += sz;

        if (precvframe.hdr.rx_tail > precvframe.hdr.rx_end)
        {
            precvframe.hdr.rx_tail -= sz;
            return;
        }

        precvframe.hdr.len += sz;
    }

    static bool rtw_os_alloc_recvframe(AdapterState padapter, recv_frame precvframe, Span<byte> pdata)
    {
        bool res = true;

        if (pdata == null)
        {
            precvframe.hdr.pkt = null;
            res = false;
            return res;
        }

        rx_pkt_attrib pattrib = precvframe.hdr.attrib;

        // Modified by Albert 20101213
        // For 8 bytes IP header alignment.
        u8 shift_sz = pattrib.qos ? (u8)6 : (u8)0; /*	Qos data, wireless lan header length is 26 */

        u32 skb_len = pattrib.pkt_len;

        /* for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
        /* modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
        u32 alloc_sz;
        if (pattrib.mfrag && (pattrib.frag_num == 0))
        {
            /* alloc_sz = 1664;	 */ /* 1664 is 128 alignment. */
            alloc_sz = (skb_len <= 1650) ? 1664 : (skb_len + 14);
        }
        else
        {
            alloc_sz = skb_len;
            /*	6 is for IP header 8 bytes alignment in QoS packet case. */
            /*	8 is for skb.data 4 bytes alignment. */
            alloc_sz += 14;
        }

        var pkt_copy = new sk_buff();

        if (pkt_copy != null)
        {
            //pkt_copy.dev = padapter.pnetdev;
            pkt_copy.len = skb_len;
            precvframe.hdr.pkt = pkt_copy;
            precvframe.hdr.rx_head = pkt_copy.head;
            precvframe.hdr.rx_end = pkt_copy.data + alloc_sz;
            skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy.data) & 7)); /* force pkt_copy.data at 8-byte alignment address */
            skb_reserve(pkt_copy, shift_sz); /* force ip_hdr at 8-byte alignment address according to shift_sz. */
            _rtw_memcpy(pkt_copy.data, pdata, skb_len);
            precvframe.hdr.rx_data = precvframe.hdr.rx_tail = pkt_copy.data;
        }
        //else
        //{
        //    if ((pattrib.mfrag) && (pattrib.frag_num == 0))
        //    {
        //        RTW_INFO("rtw_os_alloc_recvframe: alloc_skb fail , drop frag frame");
        //        /* rtw_free_recvframe(precvframe, pfree_recv_queue); */
        //        res = false;
        //        goto exit_rtw_os_recv_resource_alloc;
        //    }

        //    if (pskb == null)
        //    {
        //        res = false;
        //        goto exit_rtw_os_recv_resource_alloc;
        //    }

        //    precvframe.hdr.pkt = rtw_skb_clone(pskb);
        //    if (precvframe.hdr.pkt)
        //    {
        //        precvframe.hdr.pkt.dev = padapter.pnetdev;
        //        precvframe.hdr.rx_head = precvframe.hdr.rx_data = precvframe.u.hdr.rx_tail = pdata;
        //        precvframe.hdr.rx_end = pdata + alloc_sz;
        //    }
        //    else
        //    {
        //        RTW_INFO("rtw_os_alloc_recvframe: rtw_skb_clone fail");
        //        /* rtw_free_recvframe(precvframe, pfree_recv_queue); */
        //        /*exit_rtw_os_recv_resource_alloc;*/
        //        res = false;
        //    }
        //}

        exit_rtw_os_recv_resource_alloc:

        return res;

    }


}